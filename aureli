#!/usr/bin/env python3
import argparse
import subprocess
import sys
import os
import shlex
import json
import shutil

RUNTIME_PATH = os.path.expanduser("~/.config/aureli")
CONFIG_PATH = os.path.expanduser(RUNTIME_PATH + "/config.json")
global location
global aureli_location
aureli_location = os.path.expanduser("~/.local/share/equora")
location = os.path.expanduser(aureli_location + "/eqsh")

if os.environ.get("QT_LOGGING_RULES", False):
    os.environ["QT_LOGGING_RULES"] += ";qml.debug=true"
else:
    os.environ["QT_LOGGING_RULES"] = "qml.debug=true"

def load_config():
    with open(CONFIG_PATH, "r") as f:
        return json.load(f)

def save_config(cfg):
    with open(CONFIG_PATH, "w") as f:
        json.dump(cfg, f, indent=2)

def set_setting(key_path: str, value: str):
    cfg = load_config()
    keys = key_path.split(".")
    ref = cfg
    for k in keys[:-1]:
        if k not in ref or not isinstance(ref[k], dict):
            ref[k] = {}
        ref = ref[k]

    # Try to cast value into int/float/bool if possible
    if value.isdigit():
        val: object = int(value)
    else:
        try:
            val = float(value)
        except ValueError:
            if value.lower() in ("true", "false"):
                val = value.lower() == "true"
            else:
                val = value

    ref[keys[-1]] = val
    save_config(cfg)
    if val == True: val = "true"
    if val == False: val = "false"
    if isinstance(val, list): val = ", ".join(val)
    print(f"\033[92mSet {key_path} = {val}\033[0m")

def get_setting(key_path: str):
    cfg = load_config()
    if key_path == "all":
        print("\033[All Sections:\033[0m")
        for k in cfg:
            print(f"\033[94m- {k}\033[0m")
        return
    keys = key_path.split(".")
    ref = cfg
    for k in keys:
        if k not in ref:
            print(f"Setting {key_path} not found")
            return
        ref = ref[k]
    # style ref
    if ref == True: ref = "\033[92mtrue\033[0m"
    if ref == False: ref = "\033[91mfalse\033[0m"
    if isinstance(ref, list): ref = ", ".join(ref)
    if isinstance(ref, dict):
        final_string = ""
        def recurse(ref):
            nonlocal final_string
            for k in ref:
                if isinstance(ref[k], dict):
                    final_string += f"\033[94m{k}\033[0m\n"
                    recurse(ref[k])
                else:
                    val = ref[k]
                    if val == True: val = "true"
                    if val == False: val = "false"
                    if isinstance(val, list): val = ", ".join(val)
                    if val == "true":
                        final_string += f"\033[94m{k}\033[0m = \033[92m{val}\033[0m\n"
                    elif val == "false":
                        final_string += f"\033[94m{k}\033[0m = \033[91m{val}\033[0m\n"
                    else:
                        final_string += f"\033[94m{k}\033[0m = \033[90m{val}\033[0m\n"
        recurse(ref)
        print(final_string)
        return
    print(ref)

def reset_setting(setting: str):
    cfg = load_config()
    keys = setting.split(".")
    d = cfg
    for k in keys[:-1]:
        if k not in d:
            return  # nothing to reset
        d = d[k]
    d.pop(keys[-1], None)
    save_config(cfg)

def reset_config():
    save_config({})

def eqsh(cmd: str):
    global location
    return ("qs -p " + location + " " + cmd)

def eqsh_run(cmd: str):
    run_detached(eqsh(cmd))

def eqsh_run_dev(cmd: str):
    global location
    run(eqsh(cmd))

def ipc(*cmd: str):
    if not is_aureli_running(): exit_because("Aureli is not running")
    cmd_list = [f"\"{x}\"" if isinstance(x, str) else str(x) for x in cmd]
    eqsh_run("ipc " + "call " + " ".join(cmd_list))

def ipc_raw(*cmd: str):
    if not is_aureli_running(): exit_because("Aureli is not running")
    cmd_list = [f"\"{x}\"" if isinstance(x, str) else str(x) for x in cmd]
    eqsh_run_dev("ipc " + " ".join(cmd_list))

def ok(msg: str):
    print("\033[92m\033[38;5;46mOK: \033[0m" + msg)

def warn(msg: str):
    print("\033[93m\033[38;5;208mWARNING: \033[0m" + msg)

def err(msg: str):
    print("\033[91m\033[38;5;196mERROR: \033[0m" + msg)

def install_wallpapers():
    global aureli_location
    ok("Downloading Wallpapers...")
    try:
        # check exist
        if os.path.exists(os.path.expanduser(aureli_location + "/wallpapers")):
            warn("Wallpapers are already installed")
            if input("Do you want to overwrite them? (y/n) ").lower() == "y":
                shutil.rmtree(os.path.expanduser(aureli_location + "/wallpapers"))
            else:
                exit_because("Download aborted")
        os.system(f"git clone https://github.com/eq-desktop/wallpapers {aureli_location}/wallpapers")
        ok("Wallpapers installed")
    except Exception as e:
        err(f"Failed to install Wallpapers: {e}")

def install_aureli():
    global aureli_location
    ok("Installing Aureli...")
    try:
        # check exist
        if os.path.exists(os.path.expanduser(aureli_location)):
            warn("Aureli is already installed")
            if input("Do you want to overwrite it? (y/n) ").lower() == "y":
                shutil.rmtree(os.path.expanduser(aureli_location))
            else:
                exit_because("Installation aborted")
        # install aureli
        os.mkdir(os.path.expanduser("~/eqSh"))
        # git clone
        os.system("git clone https://github.com/eq-desktop/eqSh ~/eqSh")
        os.system("git submodule update --init --recursive")
        # mv ~/eqSh to ~/.local/share/equora
        if input("Do you want to also install wallpapers (Large files)? (y/n) ").lower() == "y":
            os.system("git clone https://github.com/eq-desktop/wallpapers ~/eqSh/wallpapers")
            print("Wallpapers installed")
        shutil.move(os.path.expanduser("~/eqSh"), os.path.expanduser(aureli_location))
        ok("Aureli installed")
        print("Post-installation steps:")
        print("- Install Quickshell https://quickshell.org")
        print("- Run `au run` to start Aureli")
    except Exception as e:
        err(f"Failed to install Aureli: {e}")

def process_name_from_pid(pid: int) -> str | None:
    try:
        with open(f"/proc/{pid}/comm", "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        return None  # process does not exist

def is_aureli_running() -> bool:
    """Check if Aureli is running or not."""

    # get json of .local/share/equora/eqsh/runtime/runtime
    contents = {}
    # if file doesnt exist
    if not os.path.exists(os.path.expanduser(RUNTIME_PATH + "/runtime")):
        return False
    with open(os.path.expanduser(RUNTIME_PATH + "/runtime"), "r") as f:
        contents = json.load(f)

    proc_id = contents["processId"]

    return process_name_from_pid(proc_id) != None

def kill_aureli():
    # get json of .local/share/equora/eqsh/runtime/runtime
    contents = {}
    # if file doesnt exist
    if not os.path.exists(os.path.expanduser(RUNTIME_PATH + "/runtime")):
        exit_because("Aureli is not running")
    with open(os.path.expanduser(RUNTIME_PATH + "/runtime"), "r") as f:
        contents = json.load(f)

    proc_id = contents["processId"]

    if not is_aureli_running():
        exit_because("Aureli is not running")

    os.kill(int(proc_id), 9)

def run_detached(cmd: str):
    """Run a command detached from this process."""
    subprocess.Popen(
        args=cmd,
        shell=True,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        start_new_session=True,
    )

def run(cmd: str, cwd: str|None=None):
    subprocess.run(
        args=cmd,
        shell=True,
        cwd=cwd
    )

def exit_because(msg: str, code: int=0):
    print(msg)
    sys.exit(code)

def main():
    global location
    global aureli_location
    parser = argparse.ArgumentParser(prog="aureli", description="Aureli Command Line Interface")
    sub = parser.add_subparsers(dest="command", required=True)
    parser.add_argument("-l", "--location", default=location, help="Location of Aureli")
    parser.add_argument("-L", "--location-aureli", default=aureli_location, help="Location to install Aureli to")

    run_cmd = sub.add_parser("run", help="Run Aureli")
    run_cmd.add_argument("--dev", action="store_true", help="Run Aureli in development mode")

    sub.add_parser("lock", help="Lock the screen")
    sub.add_parser("update", help="Look for updates")
    sub.add_parser("install", help="Install Aureli")
    sub.add_parser("installWallpapers", help="Install Aureli's default wallpapers")
    sub.add_parser("settings", help="Open settings")
    sub.add_parser("launchpad", help="Open launchpad")
    notch = sub.add_parser("new_notch_app", help="Create a new notch app")
    sub.add_parser("destroy_notch_app", help="Forcefully quits any running notch app")
    notch.add_argument("file", help="The QML file to open")
    notch.add_argument("title", help="The title of the app")
    sub.add_parser("notification_center", help="Open notification center")
    dialog = sub.add_parser("dialog", help="Open a dialog")
    dialog.add_argument("appName", help="The name of the app")
    dialog.add_argument("iconPath", help="The path to the icon")
    dialog.add_argument("title", help="The title of the dialog")
    dialog.add_argument("description", help="The description of the dialog")
    dialog.add_argument("accept", help="The text of the accept button")
    dialog.add_argument("decline", help="The text of the decline button")
    dialog.add_argument("commandAccept", help="The command to run when the accept button is clicked")
    dialog.add_argument("commandDecline", help="The command to run when the decline button is clicked")
    dialog.add_argument("customStyle", help="The custom style of the dialog")
    sub.add_parser("quit", help="Quit Aureli")
    sub.add_parser("restart", help="Restart Aureli")
    set_cmd = sub.add_parser("set", help="Set a setting")
    set_cmd.add_argument("setting", help="The setting to set (e.g. bar.height)")
    set_cmd.add_argument("value", help="The value to set the setting to")

    get_cmd = sub.add_parser("get", help="Get a setting")
    get_cmd.add_argument("setting", help="The setting to get (e.g. bar.height)")

    ipc_cmd = sub.add_parser("ipc", help="Call an IPC method")
    ipc_cmd.add_argument("method", help="The method to call")
    ipc_cmd.add_argument("args", nargs=argparse.REMAINDER, help="The arguments to pass to the method")

    sub.add_parser("funcs", help="Show all available IPC methods")

    reset_cmd = sub.add_parser("reset", help="Reset (delete) a setting")
    reset_cmd.add_argument("setting", help="The setting to reset")
    reset_cmd.add_argument("--all", action="store_true", help="Reset all settings")

    args = parser.parse_args()

    location = args.location
    aureli_location = args.location_aureli

    if args.command == "run":
        if is_aureli_running(): exit_because("Aureli is already running", 0)
        if args.dev:
            eqsh_run_dev("")
        else:
            eqsh_run("")
    elif args.command == "lock":
        ipc("eqlock", "lock")
    elif args.command == "install":
        install_aureli()
    elif args.command == "installWallpapers":
        install_wallpapers()
    elif args.command == "settings":
        ipc("settings", "toggle")
    elif args.command == "update":
        run("git pull ", cwd=os.path.expanduser(aureli_location))
    elif args.command == "launchpad":
        ipc("launchpad", "toggle")
    elif args.command == "ipc":
        ipc(args.method, *args.args)
    elif args.command == "funcs":
        ipc_raw("show")
    elif args.command == "new_notch_app":
        # code: string, timeout: int, start_delay: int
        file_contents = ""
        with open(args.file, "r") as f:
            file_contents = f.read()
        safe_contents = file_contents.replace("\\", "\\\\").replace('"', '\\"')
        ipc("notch", "instance", safe_contents)
    elif args.command == "destroy_notch_app":
        ipc("notch", "closeInstance")
    elif args.command == "dialog":
        # appName: string, icon_path: string, title: string, description: string, accept: string, decline: string, commandAccept: string, commandDecline: string, customStyle: string
        ipc("systemDialogs", "newDialog", args.appName, args.iconPath, args.title, args.description, args.accept, args.decline, args.commandAccept, args.commandDecline, args.customStyle)
    elif args.command == "notification_center":
        ipc("notificationCenter", "toggle")
    elif args.command == "quit":
        kill_aureli()
    elif args.command == "restart":
        kill_aureli()
        eqsh_run("")
    elif args.command == "set":
        set_setting(args.setting, args.value)
    elif args.command == "get":
        get_setting(args.setting)
    elif args.command == "reset":
        if args.all:
            reset_config()
            print("Reset all settings (restart required)")
        else:
            reset_setting(args.setting)
            print(f"Reset {args.setting} (restart required)")
if __name__ == "__main__":
    main()
