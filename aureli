#!/usr/bin/env python3
import argparse
import random
import string
import subprocess
import sys
import os
import shlex
import json
import shutil
import re
import subprocess
import tempfile
from pathlib import Path
from urllib.parse import urlparse
UUID = 0

####################################
#                                  #
# Kavo Parser Elephant-1           #
#                                  #
####################################

def new_part(
    name="",
    kind="object",
    type="KavoObject",
    children=None,
    path="",
    id=None,
    args=None,
    value=None,
    properties=None,
):
    global UUID
    if children is None:
        children = []
    if args is None:
        args = []
    if properties is None:
        properties = {}
    if id is None:
        id = UUID
        UUID += 1

    return {
        "name": name,
        "kind": kind,
        "type": type,
        "id": id,
        "arguments": args,
        "path": path,
        "value": value,
        "properties": properties,
        "children": children,
    }


# ---------------- Utility ---------------- #

def strip_comments(src: str) -> str:
    src = re.sub(r"//.*$", "", src, flags=re.MULTILINE)
    src = re.sub(r"/\*[\s\S]*?\*/", "", src)
    return src


def normalize_indent(block: str) -> str:
    lines = block.split("\n")

    while lines and not lines[0].strip():
        lines.pop(0)
    while lines and not lines[-1].strip():
        lines.pop()

    min_indent = float("inf")
    for line in lines:
        if not line.strip():
            continue
        match = re.match(r"^(\s+)", line)
        if match:
            min_indent = min(min_indent, len(match.group(1)))
        else:
            min_indent = 0
            break

    if not min_indent or min_indent == float("inf"):
        min_indent = 0

    return "\n".join(
        line[min_indent:] if line.startswith(" " * min_indent) else line
        for line in lines
    )


def scan_block(lines, start_index):
    state = {"in_string": False, "escape": False, "depth": 1}
    body = []
    i = start_index

    while i < len(lines):
        line = lines[i]
        for c in line:
            if state["escape"]:
                state["escape"] = False
                continue
            if c == "\\":
                state["escape"] = True
                continue
            if c == '"':
                state["in_string"] = not state["in_string"]
                continue
            if not state["in_string"]:
                if c == "{":
                    state["depth"] += 1
                if c == "}":
                    state["depth"] -= 1

        if state["depth"] == 0:
            break
        body.append(line)
        i += 1

    return {"body": "\n".join(body), "endIndex": i}


def parse_value(raw: str):
    raw = raw.strip()
    if re.match(r'^".*"$', raw):
        return {"type": "string", "value": raw[1:-1]}
    if re.match(r"^-?\d+(\.\d+)?$", raw):
        return {"type": "number", "value": float(raw) if "." in raw else int(raw)}
    if raw in ("true", "false"):
        return {"type": "boolean", "value": raw == "true"}
    return {"type": "string", "value": raw}


# ---------------- Inline Property Parser ---------------- #

def parse_inline_props(s: str):
    props = {}
    i = 0

    def skip_spaces():
        nonlocal i
        while i < len(s) and s[i].isspace():
            i += 1

    def read_key_or_flag():
        nonlocal i
        skip_spaces()
        if i < len(s) and s[i] == '"':
            i += 1
            start = i
            while i < len(s) and s[i] != '"':
                i += 1
            val = s[start:i]
            i += 1
            return val

        start = i
        while i < len(s) and not re.match(r"[\s:]", s[i]):
            i += 1
        return s[start:i]

    def read_value():
        nonlocal i
        skip_spaces()
        if i < len(s) and s[i] == '"':
            i += 1
            start = i
            while i < len(s) and s[i] != '"':
                i += 1
            val = s[start:i]
            i += 1
            return val

        start = i
        while i < len(s) and not s[i].isspace():
            i += 1
        return s[start:i]

    while i < len(s):
        skip_spaces()
        if i >= len(s):
            break

        key = read_key_or_flag()
        skip_spaces()

        if i < len(s) and s[i] == ":":
            i += 1
            raw = read_value()
            if re.match(r"^-?\d+(\.\d+)?$", raw):
                props[key] = float(raw) if "." in raw else int(raw)
            elif raw in ("true", "false"):
                props[key] = raw == "true"
            else:
                props[key] = raw
        else:
            props[key] = True

    return props


# ---------------- Parser ---------------- #

def parse(data: str, parent=None):
    data = strip_comments(data)
    lines = data.split("\n")
    root = parent or new_part(name="root", path="root")

    i = 0
    while i < len(lines):
        line = lines[i].strip()
        if not line:
            i += 1
            continue

        # IMPORT
        if line.startswith("@import "):
            file_path = re.split(r'import(?: nonfinal)?\s+', line)[1].replace('"', '').replace("'", "").strip()

            new_node = new_part(
                name="import:Unknown",
                kind="import",
                path=f"{root['path']}.import:Unknown",
                type="KavoImport",
                value=file_path,
            )
            new_node["name"] = f"import:{new_node['id']}"
            new_node["path"] = f"{root['path']}.{new_node['name']}"
            root["children"].append(new_node)
            i += 1
            continue

        # FUNCTION
        if re.match(r'^[\w]+\(.*\)\s*\{?$', line):
            name = line.split("(")[0].strip()
            args = [a.strip() for a in re.search(r'\((.*?)\)', line).group(1).split(",") if a.strip()]

            node = new_part(
                name=name,
                kind="function",
                path=f"{root['path']}.{name}",
                type="KavoFunction",
                args=args,
            )

            if "{" not in line:
                i += 1

            result = scan_block(lines, i + 1)
            node["children"].append(normalize_indent(result["body"]))
            root["children"].append(node)
            i = result["endIndex"] + 1
            continue

        # SECTION
        if "{" in line:
            name = line.split(" ")[0]
            prop_string = re.sub(r"[{}]", "", line[len(name):]).strip()
            node = new_part(name=name, kind="section", path=f"{root['path']}.{name}", type="KavoSection")

            if prop_string:
                node["properties"] = parse_inline_props(prop_string)

            result = scan_block(lines, i + 1)
            parse(result["body"], node)
            root["children"].append(node)
            i = result["endIndex"] + 1
            continue

        # PROPERTY
        if ":" in line:
            k, v = re.split(r":(.+)", line, maxsplit=1)[:-1]
            parsed = parse_value(v)
            root["children"].append(new_part(
                name=k.strip(),
                kind="property",
                path=f"{root['path']}.{k.strip()}",
                type=parsed["type"],
                value=parsed["value"],
            ))
            i += 1
            continue

        raise ValueError(f"Unknown syntax: {line}")

    return root

class KvoNode:
    def __init__(self, obj: dict):
        self._obj = obj

    # ---------- Basic access ---------- #

    @property
    def raw(self):
        return self._obj

    @property
    def children(self):
        return [KvoNode(c) for c in self._obj.get("children", [])]

    @children.setter
    def children(self, children):
        self._obj["children"] = [
            c.raw if isinstance(c, KvoNode) else c for c in children
        ]

    @property
    def id(self):
        return self._obj.get("id")

    @id.setter
    def id(self, value):
        self._obj["id"] = value

    @property
    def path(self):
        return self._obj.get("path")

    @path.setter
    def path(self, value):
        self._obj["path"] = value

    @property
    def name(self):
        return self._obj.get("name")

    @name.setter
    def name(self, value):
        self._obj["name"] = value

    @property
    def kind(self):
        return self._obj.get("kind")

    @kind.setter
    def kind(self, value):
        self._obj["kind"] = value

    @property
    def type(self):
        return self._obj.get("type")

    @type.setter
    def type(self, value):
        self._obj["type"] = value

    @property
    def args(self):
        return self._obj.get("args")

    @args.setter
    def args(self, value):
        self._obj["args"] = value

    @property
    def value(self):
        return self._obj.get("value")

    @value.setter
    def value(self, value):
        self._obj["value"] = value

    @property
    def properties(self):
        return self._obj.get("properties", {})

    @properties.setter
    def properties(self, value):
        self._obj["properties"] = value
    
    def add_property(self, key, value):
        self._obj["properties"][key] = value
    
    def remove_property(self, key):
        del self._obj["properties"][key]

    # ---------- Path helpers ---------- #

    def path_trimmed(self):
        return ".".join(self.path.split(".")[1:])

    def path_last(self):
        return self.path.split(".")[-1]

    def path_parent(self):
        return ".".join(self.path.split(".")[1:-1])

    def path_children(self):
        return self.path.split(".")[1:]

    def paths(self):
        return self.path.split(".")

    # ---------- Find ---------- #

    def find(self, name):
        return next((c for c in self.children if c.name == name), None)

    f = find

    def find_all(self, name):
        return [c for c in self.children if c.name == name]

    fA = find_all

    # ---------- Properties ---------- #

    def prop(self, key):
        return self.properties.get(key)

    p = prop

    # ---------- Filters ---------- #

    def filter_kind(self, kind):
        return [c for c in self.children if c.kind == kind]

    fK = filter_kind

    # ---------- Recursive search ---------- #

    def search(self, name):
        if self.name == name:
            return self
        for child in self.children:
            found = child.search(name)
            if found:
                return found
        return None

    s = search

    # ---------- Debug print ---------- #

    def print(self, indent=0):
        pad = " " * (indent * 2)
        out = f"{pad}{self.kind}: {self.name}\n"
        if self.kind == "function":
            return out
        for child in self.children:
            out += child.print(indent + 1)
        return out

    pr = print

    def print_now(self, indent=0):
        pad = " " * (indent * 2)
        print(f"{pad}{self.kind}: {self.name}")
        if self.kind == "function":
            return
        for child in self.children:
            child.print_now(indent + 1)

    prNow = print_now

    # ---------- Child operations ---------- #

    def map_children(self, fn):
        return [fn(c) for c in self.children]

    mC = map_children

    def has_child(self, name):
        return any(c.name == name for c in self.children)

    hC = has_child

    def add_child(self, child):
        if "children" not in self._obj:
            self._obj["children"] = []
        self._obj["children"].append(child.raw if isinstance(child, KvoNode) else child)

    def remove_child(self, id):
        self._obj["children"] = [c for c in self._obj.get("children", []) if c.get("id") != id]

    # ---------- Navigation ---------- #

    def navigate(self, path):
        if not path:
            return self

        parts = path.split(".")
        current = self

        for i, part in enumerate(parts):
            # last part → property check
            if i == len(parts) - 1 and current.prop(part) is not None:
                return current.prop(part)

            nxt = current.find(part)
            if not nxt:
                return None
            current = nxt

        return current

    n = navigate
    nav = navigate


####################################
# Normal Code

RUNTIME_PATH = os.path.expanduser("~/.config/aureli")
CONFIG_PATH = os.path.expanduser(RUNTIME_PATH + "/config.json")
PLUGIN_API_VERSION = "Elephant-1"
global location
global aureli_location
aureli_location = os.path.expanduser("~/.local/share/equora")
location = os.path.expanduser(aureli_location + "/eqsh")

if os.environ.get("QT_LOGGING_RULES", False):
    os.environ["QT_LOGGING_RULES"] += ";qml.debug=true"
else:
    os.environ["QT_LOGGING_RULES"] = "qml.debug=true"

def load_config():
    with open(CONFIG_PATH, "r") as f:
        return json.load(f)

def save_config(cfg):
    with open(CONFIG_PATH, "w") as f:
        json.dump(cfg, f, indent=2)

def set_setting(key_path: str, value: str):
    cfg = load_config()
    keys = key_path.split(".")
    ref = cfg
    for k in keys[:-1]:
        if k not in ref or not isinstance(ref[k], dict):
            ref[k] = {}
        ref = ref[k]

    # Try to cast value into int/float/bool if possible
    if value.isdigit():
        val: object = int(value)
    else:
        try:
            val = float(value)
        except ValueError:
            if value.lower() in ("true", "false"):
                val = value.lower() == "true"
            else:
                val = value

    ref[keys[-1]] = val
    save_config(cfg)
    if val == True: val = "true"
    if val == False: val = "false"
    if isinstance(val, list): val = ", ".join(val)
    print(f"\033[92mSet {key_path} = {val}\033[0m")

def get_setting(key_path: str):
    cfg = load_config()
    if key_path == "all":
        print("\033[All Sections:\033[0m")
        for k in cfg:
            print(f"\033[94m- {k}\033[0m")
        return
    keys = key_path.split(".")
    ref = cfg
    for k in keys:
        if k not in ref:
            print(f"Setting {key_path} not found")
            return
        ref = ref[k]
    # style ref
    if ref == True: ref = "\033[92mtrue\033[0m"
    if ref == False: ref = "\033[91mfalse\033[0m"
    if isinstance(ref, list): ref = ", ".join(ref)
    if isinstance(ref, dict):
        final_string = ""
        def recurse(ref):
            nonlocal final_string
            for k in ref:
                if isinstance(ref[k], dict):
                    final_string += f"\033[94m{k}\033[0m\n"
                    recurse(ref[k])
                else:
                    val = ref[k]
                    if val == True: val = "true"
                    if val == False: val = "false"
                    if isinstance(val, list): val = ", ".join(val)
                    if val == "true":
                        final_string += f"\033[94m{k}\033[0m = \033[92m{val}\033[0m\n"
                    elif val == "false":
                        final_string += f"\033[94m{k}\033[0m = \033[91m{val}\033[0m\n"
                    else:
                        final_string += f"\033[94m{k}\033[0m = \033[90m{val}\033[0m\n"
        recurse(ref)
        print(final_string)
        return
    print(ref)

def reset_setting(setting: str):
    cfg = load_config()
    keys = setting.split(".")
    d = cfg
    for k in keys[:-1]:
        if k not in d:
            return  # nothing to reset
        d = d[k]
    d.pop(keys[-1], None)
    save_config(cfg)

def reset_config():
    save_config({})

def eqsh(cmd: str):
    global location
    return ("qs -p " + location + " " + cmd)

def eqsh_run(cmd: str):
    run_detached(eqsh(cmd))

def eqsh_run_dev(cmd: str):
    global location
    run(eqsh(cmd))

def ipc(*cmd: str):
    if not is_aureli_running(): exit_because("Aureli is not running")
    cmd_list = [f"\"{x}\"" if isinstance(x, str) else str(x) for x in cmd]
    eqsh_run("ipc " + "call " + " ".join(cmd_list))

def ipc_raw(*cmd: str):
    if not is_aureli_running(): exit_because("Aureli is not running")
    cmd_list = [f"\"{x}\"" if isinstance(x, str) else str(x) for x in cmd]
    eqsh_run_dev("ipc " + " ".join(cmd_list))

def ok(msg: str):
    print("\033[92m\033[38;5;46mOK: \033[0m" + msg)

def warn(msg: str):
    print("\033[93m\033[38;5;208mWARNING: \033[0m" + msg)

def err(msg: str):
    print("\033[91m\033[38;5;196mERROR: \033[0m" + msg)

def install_wallpapers():
    global aureli_location
    ok("Downloading Wallpapers...")
    try:
        # check exist
        if os.path.exists(os.path.expanduser(aureli_location + "/wallpapers")):
            warn("Wallpapers are already installed")
            if input("Do you want to overwrite them? (y/n) ").lower() == "y":
                shutil.rmtree(os.path.expanduser(aureli_location + "/wallpapers"))
            else:
                exit_because("Download aborted")
        os.system(f"git clone https://github.com/eq-desktop/wallpapers {aureli_location}/wallpapers")
        ok("Wallpapers installed")
    except Exception as e:
        err(f"Failed to install Wallpapers: {e}")

def install_aureli():
    global aureli_location
    ok("Installing Aureli...")
    try:
        # check exist
        if os.path.exists(os.path.expanduser(aureli_location)):
            warn("Aureli is already installed")
            if input("Do you want to overwrite it? (y/n) ").lower() == "y":
                shutil.rmtree(os.path.expanduser(aureli_location))
            else:
                exit_because("Installation aborted")
        # install aureli
        os.mkdir(os.path.expanduser("~/eqSh"))
        # git clone
        os.system("git clone https://github.com/eq-desktop/eqSh ~/eqSh")
        os.system("git submodule update --init --recursive")
        # mv ~/eqSh to ~/.local/share/equora
        if input("Do you want to also install wallpapers (Large files)? (y/n) ").lower() == "y":
            os.system("git clone https://github.com/eq-desktop/wallpapers ~/eqSh/wallpapers")
            print("Wallpapers installed")
        shutil.move(os.path.expanduser("~/eqSh"), os.path.expanduser(aureli_location))
        # mkdir .config/aureli/
        # mkdir .config/aureli/plugins
        os.mkdir(os.path.expanduser("~/.config/aureli"))
        os.mkdir(os.path.expanduser("~/.config/aureli/plugins"))
        # install plugins
        install_plugin("https://github.com/eq-desktop/Aureli-Base-Plugin")
        ok("Aureli installed")
        print("Post-installation steps:")
        print("- Install Quickshell https://quickshell.org")
        print("- Run `au run` to start Aureli")
    except Exception as e:
        err(f"Failed to install Aureli: {e}")

def process_name_from_pid(pid: int) -> str | None:
    try:
        with open(f"/proc/{pid}/comm", "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        return None  # process does not exist

def is_aureli_running() -> bool:
    """Check if Aureli is running or not."""

    # get json of .local/share/equora/eqsh/runtime/runtime
    contents = {}
    # if file doesnt exist
    if not os.path.exists(os.path.expanduser(RUNTIME_PATH + "/runtime")):
        return False
    with open(os.path.expanduser(RUNTIME_PATH + "/runtime"), "r") as f:
        contents = json.load(f)

    proc_id = contents["processId"]

    return process_name_from_pid(proc_id) != None

def kill_aureli():
    # get json of .local/share/equora/eqsh/runtime/runtime
    contents = {}
    # if file doesnt exist
    if not os.path.exists(os.path.expanduser(RUNTIME_PATH + "/runtime")):
        exit_because("Aureli is not running")
    with open(os.path.expanduser(RUNTIME_PATH + "/runtime"), "r") as f:
        contents = json.load(f)

    proc_id = contents["processId"]

    if not is_aureli_running():
        exit_because("Aureli is not running")

    os.kill(int(proc_id), 9)

def get_plugins():
    plugins = []
    dirs = os.listdir(os.path.expanduser(RUNTIME_PATH + "/plugins"))
    for directory in dirs:
        # Read plugin.kvo file inside plugins
        content = ""
        with open(os.path.expanduser(RUNTIME_PATH + "/plugins/" + directory + "/plugin.kvo"), "r") as f:
            content = f.read()
        kavo = KvoNode(parse(content))
        kavo.add_property("directory", directory)
        files_of_dir = os.listdir(os.path.expanduser(RUNTIME_PATH + "/plugins/" + directory))
        files = {}
        for file in files_of_dir:
            if file.endswith(".kvo"):
                with open(os.path.expanduser(RUNTIME_PATH + "/plugins/" + directory + "/" + file), "r") as f:
                    files[file] = f.read()
        imports = kavo.nav("plugin").filter_kind("import")
        for import_ in imports:
            import_path = import_.value
            if import_path.startswith("/"): pass
            elif import_path.startswith("./"):
                import_path = import_path[2:]
            else: pass
            import_nav_path = import_.path_parent()
            import_file = files[import_path]
            import_kvo = KvoNode(parse(import_file))
            for child in import_kvo.children:
                kavo.nav(import_nav_path).add_child(child)
            kavo.nav(import_nav_path).remove_child(import_.id)
        plugins.append(kavo)
    return plugins

def get_plugin(id: str):
    plugins = get_plugins()
    for plugin in plugins:
        props = plugin.nav("plugin").properties
        key = next(iter(props))
        if key == id:
            return plugin

def prompt_default(text: str, default: str) -> str:
    """
    Prompt the user with a default value.
    If user presses Enter, default is returned.
    """
    response = input(f"{text} [{default}]: ").strip()
    return response or default    

def install_plugin(url: str):
    # --- Validate URL ---
    if not (url.startswith("https://") or url.startswith("http://") or url.startswith("git@")):
        raise ValueError("Only git/http(s) URLs are allowed")

    plugins_dir = Path(RUNTIME_PATH) / "plugins"
    plugins_dir.mkdir(parents=True, exist_ok=True)

    # --- Clone to temp dir ---
    with tempfile.TemporaryDirectory(prefix="aureli-plugin-") as tmp:
        tmp_path = Path(tmp)

        result = subprocess.run(
            [
                "git", "clone",
                "--depth", "1",
                "--filter=blob:none",
                url,
                str(tmp_path)
            ],
            capture_output=True,
            text=True,
            timeout=25
        )

        if result.returncode != 0:
            raise RuntimeError(f"Git clone failed:\n{result.stderr}")

        # --- Read metadata ---
        kvo_file = tmp_path / "plugin.kvo"
        if not kvo_file.exists():
            raise FileNotFoundError("plugin.kvo not found in repository")

        content = kvo_file.read_text()
        kavo = KvoNode(parse(content))

        plugin_id = next(iter(kavo.nav("plugin").properties), None)
        if not plugin_id:
            raise ValueError("Plugin ID missing in plugin.kvo")

        # --- Check if already installed ---
        if get_plugin(plugin_id):
            raise FileExistsError(f"Plugin '{plugin_id}' is already installed")

        # --- Final destination uses ID, not repo name ---
        target_dir = plugins_dir / plugin_id

        shutil.move(str(tmp_path), target_dir)

    ok(f"Plugin '{plugin_id}' installed")

def new_plugin():
    print("Creating new Aureli plugin...")

    while True:
        dir_name = input("Enter the plugin folder name (or '.' for current folder): ").strip()
        if not dir_name:
            print("Folder name cannot be empty")
            continue

        if dir_name == ".":
            target_path = Path.cwd()
        else:
            target_path = Path.cwd() / dir_name
            if target_path.exists():
                print(f"Folder '{dir_name}' already exists. Pick another name.")
                continue
            target_path.mkdir(parents=True)

        print(f"Plugin development folder ready at: {target_path}")
        break

    print("\nEnter plugin metadata:")
    plugin_name = prompt_default("Plugin Name", "MyPlugin")
    plugin_id = prompt_default("Plugin Id", plugin_name.lower().replace(" ", "-"))
    plugin_author = prompt_default("Author", "Anonymous")
    plugin_version = prompt_default("Version", "0.1.0")
    plugin_api = prompt_default("API Version", PLUGIN_API_VERSION)
    plugin_description = prompt_default("Description", "A new Aureli plugin")

    kvo_content = f"""plugin "{plugin_id}" {{
  meta {{
    name: "{plugin_name}"
    author: "{plugin_author}"
    version: "{plugin_version}"
    api: "{plugin_api}"
    description: "{plugin_description}"
  }}
}}
"""

    kvo_path = target_path / "plugin.kvo"
    kvo_path.write_text(kvo_content, encoding="utf-8")
    ok(f"plugin.kvo created at {kvo_path}")


def load_plugin(source_folder: str):
    source_path = Path(source_folder).expanduser().resolve()
    if not source_path.exists() or not source_path.is_dir():
        raise FileNotFoundError(f"Source folder '{source_folder}' does not exist or is not a directory")

    kvo_file = source_path / "plugin.kvo"
    if not kvo_file.exists():
        raise FileNotFoundError(f"No 'plugin.kvo' found in {source_path}")

    # Read metadata
    content = kvo_file.read_text(encoding="utf-8")
    kavo = KvoNode(parse(content))
    meta = kavo.nav("plugin.meta")
    plugin_id = meta.prop("directory")
    if not plugin_id:
        raise ValueError("plugin.kvo is missing the 'directory' field in meta")

    # Destination path
    plugins_dir = Path(RUNTIME_PATH) / "plugins"
    plugins_dir.mkdir(parents=True, exist_ok=True)
    target_path = plugins_dir / plugin_id

    if target_path.exists():
        raise FileExistsError(f"Plugin '{plugin_id}' is already installed")

    # Copy folder
    shutil.copytree(source_path, target_path)
    ok(f"Plugin '{meta.nav('name').value}' loaded into plugins folder as '{plugin_id}'")

def meta_plugin(url: str):
    if not (url.startswith("https://") or url.startswith("http://") or url.startswith("git@")):
        raise ValueError("Only git/http(s) URLs are allowed")

    with tempfile.TemporaryDirectory(prefix="aureliplugin-") as tmp:
        tmp_path = Path(tmp)

        result = subprocess.run(
            ["git", "clone", "--depth", "1", "--filter=blob:none", url, str(tmp_path)],
            capture_output=True,
            text=True,
            timeout=20
        )
        if result.returncode != 0:
            raise RuntimeError(f"Git clone failed:\n{result.stderr}")

        kvo_file = tmp_path / "plugin.kvo"
        if not kvo_file.exists():
            raise FileNotFoundError("plugin.kvo not found in repository")

        content = kvo_file.read_text(encoding="utf-8")
        kavo = KvoNode(parse(content))

        plugin_node = kavo.nav("plugin")
        plugin_id = next(iter(plugin_node.properties), None)

        meta = plugin_node.nav("meta")

        installed = get_plugin(plugin_id) is not None

        print(f"\nInformation for '{meta.nav('name').value}' Plugin")
        print("─" * 40)
        print(f"Name:        {meta.nav('name').value}")
        print(f"ID:          {plugin_id}")
        print(f"Version:     {meta.nav('version').value}")
        print(f"API:         {meta.nav('api').value}")
        print(f"Author:      {meta.nav('author').value}")
        print(f"Description: {meta.nav('description').value}")
        print(f"Installed:   {'Yes' if installed else 'No'}")

def uninstall_plugin(id: str):
    plugin = get_plugin(id)
    if plugin is None:
        raise FileNotFoundError(f"Plugin '{id}' is not installed")

    plugin_dir_name = plugin.prop("directory")
    if not plugin_dir_name:
        raise FileNotFoundError(f"Plugin '{id}' does not have a directory assigned")

    plugin_dir = Path(RUNTIME_PATH) / "plugins" / plugin_dir_name

    if not plugin_dir.exists():
        raise FileNotFoundError(f"Plugin '{id}' directory '{plugin_dir}' not found")

    try:
        shutil.rmtree(plugin_dir)
    except Exception as e:
        raise RuntimeError(f"Failed to remove plugin '{id}': {e}")

    ok(f"Plugin '{id}' uninstalled successfully")

def update_plugin(id: str):
    plugin = get_plugin(id)
    if plugin is None:
        raise FileNotFoundError(f"Plugin '{id}' is not installed")

    plugin_dir_name = plugin.prop("directory")
    if not plugin_dir_name:
        raise FileNotFoundError(f"Plugin '{id}' does not have a directory assigned")

    plugin_dir = Path(RUNTIME_PATH) / "plugins" / plugin_dir_name

    if not plugin_dir.exists():
        raise FileNotFoundError(f"Plugin '{id}' directory '{plugin_dir}' not found")

    if not (plugin_dir / ".git").exists():
        raise RuntimeError(f"Plugin '{id}' is not a git repository, cannot update")

    try:
        result = subprocess.run(
            ["git", "-C", str(plugin_dir), "pull", "--ff-only"],
            capture_output=True,
            text=True,
            timeout=30
        )
        if result.returncode != 0:
            raise RuntimeError(f"Update failed:\n{result.stderr.strip()}")
    except subprocess.TimeoutExpired:
        raise RuntimeError(f"Update timed out for plugin '{id}'")

    ok(f"Plugin '{id}' updated successfully")

def list_plugins():
    plugins = get_plugins()

    for plugin in plugins:
        try:
            props = plugin.nav("plugin").properties or {}
            key = next(iter(props), "unknown")

            name = plugin.nav("plugin.meta.name").value
            author = plugin.nav("plugin.meta.author").value

            print(" · " + "\033[90m" + f"{name} — {author}" + "\033[0m")
            print(" ├ Id: " + "\033[94m" + key + "\033[0m")
            print(" └ Enabled: " + "\033[92menabled\033[0m")
        except Exception as e:
            print(" · \033[91mBroken plugin\033[0m:", e)

def versions():
    print("\033[96mInfo\033[0m\n")

    # --- Kavo ---
    print("\033[94mKavo Format\033[0m")
    print(f"  Version : \033[96m{PLUGIN_API_VERSION}\033[0m")
    print()

    # --- CLI ---
    print("\033[94mAureli\033[0m")
    print(f"  CLI Version   : \033[96m0.1.0\033[0m")
    print(f"  Install Path  : \033[96m{os.path.expanduser(aureli_location)}\033[0m")
    print(f"  Runtime Path  : \033[96m{os.path.expanduser(RUNTIME_PATH)}\033[0m")
    print()

    # --- Python ---
    print("\033[94mRuntime\033[0m")
    print(f"  Python        : \033[96m{sys.version.split()[0]}\033[0m")
    print()

def compile_plugin(id: str, compact: bool):
    plugins = get_plugins()
    # get plugin
    for plugin in plugins:
        props = plugin.nav("plugin").properties
        key = next(iter(props))
        if key == id:
            print(json.dumps(plugin.raw, indent=None if compact else 4))
            return

def run_detached(cmd: str):
    """Run a command detached from this process."""
    subprocess.Popen(
        args=cmd,
        shell=True,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        start_new_session=True,
    )

def run(cmd: str, cwd: str|None=None):
    subprocess.run(
        args=cmd,
        shell=True,
        cwd=cwd
    )

def exit_because(msg: str, code: int=0):
    print(msg)
    sys.exit(code)

command_map = {
    "v": "version",
    "q": "quit",
    "rs": "restart",
    "p": "plugin",
    "i": "ipc",
    "s": "set",
    "g": "get",
    "r": "run",
}

def main():
    global location
    global aureli_location
    parser = argparse.ArgumentParser(prog="aureli", description="Aureli Command Line Interface")
    sub = parser.add_subparsers(dest="command", required=True)
    parser.add_argument("-l", "--location", default=location, help="Location of Aureli")
    parser.add_argument("-L", "--location-aureli", default=aureli_location, help="Location to install Aureli to")

    run_cmd = sub.add_parser("run", aliases=["r"], help="Run Aureli")
    run_cmd.add_argument("--dev", action="store_true", help="Run Aureli in development mode")

    plugin = sub.add_parser("plugin", aliases=["p"], help="Manage plugins")
    plugin_sub = plugin.add_subparsers(dest="plugin_command", required=True)

    plugin_install = plugin_sub.add_parser("install", aliases=["i"], help="Install a plugin")
    plugin_install.add_argument("url", help="The URL of the plugin")

    plugin_uninstall = plugin_sub.add_parser("uninstall", aliases=["rm"], help="Uninstall a plugin")
    plugin_uninstall.add_argument("id", help="The name of the plugin")

    plugin_list = plugin_sub.add_parser("list", aliases=["l"], help="List installed plugins")

    plugin_meta = plugin_sub.add_parser("meta", aliases=["m"], help="Get plugin meta")
    plugin_meta.add_argument("url", help="The URL of the plugin")

    plugin_update = plugin_sub.add_parser("update", aliases=["u"], help="Update a plugin")
    plugin_update.add_argument("id", help="The name of the plugin")

    plugin_new = plugin_sub.add_parser("new", aliases=["n"], help="Create a new plugin")

    plugin_load = plugin_sub.add_parser("load", help="Load a plugin from a directory")
    plugin_load.add_argument("dir", help="The directory of the plugin")

    plugin_compile = plugin_sub.add_parser("compile", aliases=["c"], help="Compile a plugin")
    plugin_compile.add_argument("id", help="The name of the plugin")
    plugin_compile.add_argument("--compact", action="store_true", help="Don't Indent the plugin")

    sub.add_parser("lock", help="Lock the screen")
    sub.add_parser("update", help="Look for updates")
    sub.add_parser("version", aliases=["v"], help="Show Aureli version")
    sub.add_parser("install", help="Install Aureli")
    sub.add_parser("installWallpapers", help="Install Aureli's default wallpapers")
    sub.add_parser("settings", help="Open settings")
    sub.add_parser("launchpad", help="Open launchpad")
    notch = sub.add_parser("new_notch_app", help="Create a new notch app")
    sub.add_parser("destroy_notch_app", help="Forcefully quits any running notch app")
    notch.add_argument("file", help="The QML file to open")
    notch.add_argument("title", help="The title of the app")
    sub.add_parser("notification_center", help="Open notification center")
    dialog = sub.add_parser("dialog", help="Open a dialog")
    dialog.add_argument("appName", help="The name of the app")
    dialog.add_argument("iconPath", help="The path to the icon")
    dialog.add_argument("title", help="The title of the dialog")
    dialog.add_argument("description", help="The description of the dialog")
    dialog.add_argument("accept", help="The text of the accept button")
    dialog.add_argument("decline", help="The text of the decline button")
    dialog.add_argument("commandAccept", help="The command to run when the accept button is clicked")
    dialog.add_argument("commandDecline", help="The command to run when the decline button is clicked")
    dialog.add_argument("customStyle", help="The custom style of the dialog")
    sub.add_parser("quit", aliases=["q"], help="Quit Aureli")
    sub.add_parser("restart", aliases=["rs"], help="Restart Aureli")
    set_cmd = sub.add_parser("set", aliases=["s"], help="Set a setting")
    set_cmd.add_argument("setting", help="The setting to set (e.g. bar.height)")
    set_cmd.add_argument("value", help="The value to set the setting to")

    get_cmd = sub.add_parser("get", aliases=["g"], help="Get a setting")
    get_cmd.add_argument("setting", help="The setting to get (e.g. bar.height)")

    ipc_cmd = sub.add_parser("ipc", aliases=["i"], help="Call an IPC method")
    ipc_cmd.add_argument("method", help="The method to call")
    ipc_cmd.add_argument("args", nargs=argparse.REMAINDER, help="The arguments to pass to the method")

    sub.add_parser("funcs", help="Show all available IPC methods")

    reset_cmd = sub.add_parser("reset", help="Reset (delete) a setting")
    reset_cmd.add_argument("setting", help="The setting to reset")
    reset_cmd.add_argument("--all", action="store_true", help="Reset all settings")

    args = parser.parse_args()

    location = args.location
    aureli_location = args.location_aureli

    if args.command in command_map:
        args.command = command_map[args.command]

    if args.command == "plugin":
        if args.plugin_command == "install":
            install_plugin(args.url)
        elif args.plugin_command == "uninstall":
            uninstall_plugin(args.id)
        elif args.plugin_command == "update":
            update_plugin(args.id)
        elif args.plugin_command == "new":
            new_plugin()
        elif args.plugin_command == "load":
            load_plugin(args.dir)
        elif args.plugin_command == "meta":
            meta_plugin(args.url)
        elif args.plugin_command == "list":
            list_plugins()
        elif args.plugin_command == "compile":
            compile_plugin(args.id, args.compact)
    elif args.command == "version":
        versions()
    elif args.command == "run":
        if is_aureli_running(): exit_because("Aureli is already running", 0)
        if args.dev:
            eqsh_run_dev("")
        else:
            eqsh_run("")
    elif args.command == "lock":
        ipc("eqlock", "lock")
    elif args.command == "install":
        install_aureli()
    elif args.command == "installWallpapers":
        install_wallpapers()
    elif args.command == "settings":
        ipc("settings", "toggle")
    elif args.command == "update":
        run("git pull ", cwd=os.path.expanduser(aureli_location))
    elif args.command == "launchpad":
        ipc("launchpad", "toggle")
    elif args.command == "ipc":
        ipc(args.method, *args.args)
    elif args.command == "funcs":
        ipc_raw("show")
    elif args.command == "new_notch_app":
        # code: string, timeout: int, start_delay: int
        file_contents = ""
        with open(args.file, "r") as f:
            file_contents = f.read()
        safe_contents = file_contents.replace("\\", "\\\\").replace('"', '\\"')
        ipc("notch", "instance", safe_contents)
    elif args.command == "destroy_notch_app":
        ipc("notch", "closeInstance")
    elif args.command == "dialog":
        # appName: string, icon_path: string, title: string, description: string, accept: string, decline: string, commandAccept: string, commandDecline: string, customStyle: string
        ipc("systemDialogs", "newDialog", args.appName, args.iconPath, args.title, args.description, args.accept, args.decline, args.commandAccept, args.commandDecline, args.customStyle)
    elif args.command == "notification_center":
        ipc("notificationCenter", "toggle")
    elif args.command == "quit":
        kill_aureli()
    elif args.command == "restart":
        kill_aureli()
        eqsh_run("")
    elif args.command == "set":
        set_setting(args.setting, args.value)
    elif args.command == "get":
        get_setting(args.setting)
    elif args.command == "reset":
        if args.all:
            reset_config()
            print("Reset all settings (restart required)")
        else:
            reset_setting(args.setting)
            print(f"Reset {args.setting} (restart required)")
if __name__ == "__main__":
    main()
